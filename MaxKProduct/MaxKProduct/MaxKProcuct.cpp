#define _CRT_SECURE_NO_WARNINGS 1
// ######################################################################## //
//
//  本程序使用动态规划法解决 '最大 k 乘积' 问题.
//
//  创建日期: 2016-04-03
//
//  修改记录:
//  ( 1 ) 2016-04-03 创建了初始版本( v0.10 )
//
//  版 本 号: v0.10
//
//  备    注: 使用标准 C 代码实现
//
//  作    者: 刘伟
//
// ######################################################################## //

// 使用的库定义
#include < stdio.h >
#include < stdlib.h >
#include < string.h >
#include <math.h>
// ######################################################################## //
//                                                                          // 
//                              下面是数据定义区                               // 
//                                                                          // 
// ######################################################################## //

#define STR_LEN 100
#define TRUE    1
#define FALSE   0

//////////////////////////////////////////////////////////////////////////////


// ######################################################################## //
//                                                                          // 
//                           下面是各个子函数定义                               // 
//                                                                          // 
// ######################################################################## //

int  CalcMaxKProduct(int n, int k, int** D, int** P);
void PrintProductMatrix(int n, int k, int** D, int** P);

//////////////////////////////////////////////////////////////////////////////

// ######################################################################## //
//                                                                          // 
//                          下面是各个子函数的实现                             // 
//                                                                          // 
// ######################################################################## //

// 使用动态规划法计算两个字符串之间的编辑距离 ...
//
// 测试数据如下 :
// ( 1 ) 1234 划分为 3 段 : 12 * 3 * 4 = 144
// ( 2 ) 自行设计 2 个测试用例
int w(int* I,int a, int b)
{
    if (a == b)
        return I[a];
    int sum = 0;
    for (int i = a; i <= b; ++i)
    {
        sum = sum * 10 + I[i];
    }
    return sum;
}

int CalcMaxKProduct(int* I, int n, int k, int** D, int** P)
{
    int i, j, t, maxv, tk;

    // 请将下面的代码补充完毕, 使程序可以正确运行 ...
    // ......
    // D[i][j]:表示I的第i位数字到第j为数字
    // P[i][j]:表示I的前i位数字分成k段的最大乘积
    if (n < k)
        return 0;
    if (k == 1)
        return n;


    for (int i = 1; i <= n; ++i)
    {
        for (int j = i; j <= n; ++j)
        {
            D[i][j] = w(I, i, j);
        }
    }
    
    for (i = 1; i <= n; ++i)
    {
        for (j = 1; j <= k; ++j)
        {
            // P[i][j] = D[1][i]
            if (j == 1)
            {
                P[i][j] = D[1][i]; continue;
            }
            // P[i][j] = max(P[i][j+1] , P[tk][j - 1] * D[tk + 1][i])
            for (int tk = 1; tk < i; tk++)
            {
                P[i][j] = P[i][j+1] > P[tk][j - 1] * D[tk + 1][i] ? P[i][j] : P[tk][j - 1] * D[tk + 1][i];
            }
        }
    }
    return P[n][k];
}

// 打印编辑距离矩阵 ...
void PrintProductMatrix(int* I,int n, int k, int** D, int** P)
{
    int i, j;

    // 打印 'D' ...
    printf("\t生成的整数分段值矩阵为 : \n");

    // 请将下面的代码补充完毕, 使程序可以正确运行 ...
    // ......
    for (int i = 1; i <= n; ++i)
    {
        for (int j = 1; j <= n; ++j)
        {
            printf("\t%d  ",D[i][j]);
        }
        printf("\n");
    }
    printf("\n\n");

    // 打印 'P' ...
    printf("\t生成的分段乘积矩阵为 : \n");

    // 请将下面的代码补充完毕, 使程序可以正确运行 ...
    // ......
    for (int i = 1; i <= n; ++i)
    {
        for (int j = 1; j <= k; ++j)
        {
            printf("\t%d  ", P[i][j]);
        }
        printf("\n");
    }
    printf("\n\n");
}

//////////////////////////////////////////////////////////////////////////////

// ######################################################################## //
//                                                                          // 
//                             下面是主程序的实现                              // 
//                                                                          // 
// ######################################################################## //

void main(void)
{
    char StrI[STR_LEN];
    char StrK[STR_LEN];
    int* I, n;    // 储存输入的整数及其长度 ...
    int  k;        // 输入的整数分为 'k' 段 ...
    int** D, ** P; // 二维数组, 储存整数的各个分段值及乘积值 ...
    int  i, j, MaxProduct;
    int  IsStop;

    IsStop = FALSE;
    while (!IsStop)
    {
        // 清屏 ...
        system("cls");

        // 输入整数 'I' ...
        printf("\n\n\t请输入 < 整数 I 的值 > ， 输入 < q / Q > 表示结束 : ");
        scanf("%s", StrI);
        n = strlen(StrI); // 输入整数的位数 ...
        if (n > 0)
            IsStop = ((StrI[0] == 'q') || (StrI[0] == 'Q'));
        else
            printf("\t输入的整数不能为空 !\n\n");

        if (!IsStop)
        {
            // 输入分段数 'k' ...
            printf("\n\t请输入 < 整数分段数 k > ， 输入 < q / Q > 表示结束 : ");
            scanf("%s", StrK);
            if (strlen(StrK) > 0)
                IsStop = ((StrK[0] == 'q') || (StrK[0] == 'Q'));
            else
                printf("\t输入的整数分段数不能为空 !\n\n");

            // 输入的整数及其分段数 'I' 和 'k' 均不为空, 则计算最大 'k' 乘积 ...
            if (!IsStop)
            {
                // 将输入的字符串转换为整数 ...

                // 输入的整数 'I' ...

                // 动态申请一维数组 ...
                I = (int*)malloc((n + 1) * sizeof(int));

                // 将输入的字符串整数的每一位放入 'I' 中 ...
                for (i = 1; i <= n; i++)
                    I[i] = StrI[i - 1] - '0'; // 注意序号起始值 ...

                  // 输入的分段数 'k' ...
                k = atoi(StrK);

                // 动态申请二维数组 'D' 和 'P' ...

                // 'D' - 储存整数的各个分段值( n x n 阵 ) ...
                D = (int**)malloc((n + 1) * sizeof(int));
                for (i = 0; i <= n; i++)
                    D[i] = (int*)malloc((n + 1) * sizeof(int));
                // 初始化 ...
                for (i = 0; i <= n; i++)
                    for (j = 0; j <= n; j++)
                        D[i][j] = 0;

                // 'P' - 储存整数的分段乘积值( n x k 阵 ) ...
                P = (int**)malloc((n + 1) * sizeof(int));
                for (i = 0; i <= n; i++)
                    P[i] = (int*)malloc((k + 1) * sizeof(int));
                // 初始化 ...
                for (i = 0; i <= n; i++)
                    for (j = 0; j <= k; j++)
                        P[i][j] = 0;

                // 生成 'D' 矩阵 ...

                // 请将下面的代码补充完毕, 使程序可以正确运行 ...
                // ......

                // 计算最大 'k' 乘积 ...
                MaxProduct = CalcMaxKProduct(I, n, k, D, P);

                // 显示计算结果 ...
                printf("\n\t< 计算得到的最大 k 乘积为：%d > \n\n", MaxProduct);

                // 打印数值矩阵 ...
                PrintProductMatrix(I, n, k, D, P);

                // 释放二维数组 'D' 和 'P' 的空间 ...
                for (i = 0; i <= n; i++)
                    free(D[i]);
                free(D);

                for (i = 0; i <= n; i++)
                    free(P[i]);
                free(P);

                // 等待用户输入任意一键返回 ...
                printf("\n\n");
                system("PAUSE");
            }
        }
    }

    // 等待用户输入任意一键返回 ...
    printf("\n\n");
    system("PAUSE");
}

//////////////////////////////////////////////////////////////////////////////
